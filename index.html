<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>æƒ…ç»ªæ˜Ÿäº‘ Pro - æƒ…æ„ŸåŒ–ç²’å­ç³»ç»Ÿ</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoi5a2m56We5piT6ZuoIFBybyIsInNob3J0X25hbWUiOiLlrabnpZkiLCJzdGFydF91cmwiOiIuIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzAwMDAwMCIsInRoZW1lX2NvbG9yIjoiIzAwMDAwMCIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDEwMCAxMDAnJTNFJTNDY2lyY2xlIGN4PSc1MCcgY3k9JzUwJyByPSc0NScgZmlsbD0ndXJsKCNncmFkKScanLyUzRSUzQ2RlZnMlM0UlM0NyYWRpYWxHcmFkaWVudCBpZD0nZ3JhZCclM0UlM0NzdG9wIG9mZnNldD0nMCUnIHN0b3AtY29sb3I9JyNGRjZCNkInLyUzRSUzQ3N0b3Agb2Zmc2V0PScxMDAlJyBzdG9wLWNvbG9yPScjNDVFQ0Q0JyUzRSUzQy9yYWRpYWxHcmFkaWVudCUzRSUzQy9kZWZzJTNFJTNDL3N2ZyUzRSIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">

  <style>
    /* ==================== å…¨å±€æ ·å¼ ==================== */
    :root {
      --primary-glow: rgba(78, 205, 196, 0.6);
      --accent-glow: rgba(255, 107, 107, 0.5);
      --glass-bg: rgba(20, 20, 30, 0.75);
      --glass-border: rgba(255, 255, 255, 0.12);
      --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      --text-primary: rgba(255, 255, 255, 0.95);
      --text-secondary: rgba(255, 255, 255, 0.65);
      --transition-smooth: cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* ==================== å®¹å™¨ ==================== */
    .container {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background: #0a0a0f;
      transition: background 3s ease;
    }

    .container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.3) 100%);
      pointer-events: none;
      z-index: 1;
    }

    /* ==================== Canvasç”»å¸ƒ ==================== */
    #particleCanvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      position: relative;
      z-index: 2;
    }

    /* ==================== æ–‡å­—ç²’å­å±‚ ==================== */
    .text-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
    }

    .text-particle {
      position: absolute;
      font-weight: 300;
      text-shadow:
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 30px currentColor;
      transition: opacity 0.5s ease;
      will-change: transform;
      white-space: nowrap;
      filter: brightness(1.2);
    }

    /* ==================== é¡¶éƒ¨å¯¼èˆªæ  ==================== */
    .top-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 80px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 30px;
      z-index: 100;
      background: linear-gradient(to bottom, rgba(10, 10, 15, 0.9), transparent);
    }

    /* Logo */
    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
      animation: slideInLeft 0.6s ease;
    }

    .logo-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--primary-glow), var(--accent-glow));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
    }

    .logo-text {
      display: flex;
      flex-direction: column;
    }

    .logo-title {
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
    }

    .logo-subtitle {
      font-size: 10px;
      color: var(--text-secondary);
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    /* å¿«æ·é”®é¢æ¿ */
    .shortcuts-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      padding: 12px 18px;
      border-radius: 14px;
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
      animation: slideInRight 0.6s ease;
    }

    .shortcuts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px 20px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .shortcut-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .shortcut-item kbd {
      background: rgba(255, 255, 255, 0.1);
      padding: 3px 8px;
      border-radius: 6px;
      font-family: 'SF Mono', 'Monaco', monospace;
      font-size: 10px;
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.15);
      min-width: 24px;
      text-align: center;
    }

    /* ==================== æƒ…ç»ªæŒ‡ç¤ºå™¨ ==================== */
    .emotion-indicator {
      position: absolute;
      top: 100px;
      left: 30px;
      display: flex;
      align-items: center;
      gap: 16px;
      z-index: 100;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      padding: 16px 24px;
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
      animation: slideInLeft 0.8s ease;
      transition: all 0.3s ease;
    }

    .emotion-indicator:hover {
      transform: translateX(5px);
      box-shadow: 0 12px 40px rgba(78, 205, 196, 0.3);
    }

    .emotion-icon {
      font-size: 36px;
      filter: drop-shadow(0 4px 12px rgba(255, 255, 255, 0.3));
      animation: pulse 2s ease-in-out infinite;
    }

    .emotion-name {
      color: var(--text-primary);
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .emotion-desc {
      display: none;
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    /* ==================== æƒ…ç»ªé€‰æ‹©å™¨ ==================== */
    .emotion-dock {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      padding: 14px 20px;
      border-radius: 24px;
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
      animation: slideInUp 0.8s ease;
    }

    .emotion-btn {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      border: 2px solid transparent;
      background: rgba(255, 255, 255, 0.08);
      font-size: 26px;
      cursor: pointer;
      transition: all 0.3s var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .emotion-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.2), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .emotion-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 8px 20px rgba(78, 205, 196, 0.4);
    }

    .emotion-btn:hover::before {
      opacity: 1;
    }

    .emotion-btn.active {
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
      box-shadow:
        0 0 20px rgba(78, 205, 196, 0.5),
        0 8px 25px rgba(78, 205, 196, 0.3);
    }

    .emotion-btn:active {
      transform: scale(0.95);
    }

    /* ==================== æ§åˆ¶é¢æ¿ ==================== */
    .control-panel {
      position: absolute;
      bottom: 40px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
      animation: slideInRight 0.8s ease;
    }

    .btn-control {
      width: 56px;
      height: 56px;
      border-radius: 16px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      color: #fff;
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--glass-border);
      padding: 0;
      cursor: pointer;
      transition: all 0.3s var(--transition-smooth);
      box-shadow: var(--glass-shadow);
      position: relative;
      overflow: hidden;
    }

    .btn-control::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.15), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .btn-control:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: scale(1.08);
      box-shadow:
        0 8px 25px rgba(78, 205, 196, 0.4),
        0 0 15px rgba(78, 205, 196, 0.3);
    }

    .btn-control:hover::before {
      opacity: 1;
    }

    .btn-control:active {
      transform: scale(0.95);
    }

    /* Tooltip */
    .btn-control::after {
      content: attr(data-tooltip);
      position: absolute;
      right: 70px;
      top: 50%;
      transform: translateY(-50%) translateX(10px);
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      color: var(--text-primary);
      padding: 8px 14px;
      border-radius: 10px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      border: 1px solid var(--glass-border);
    }

    .btn-control:hover::after {
      opacity: 1;
      transform: translateY(-50%) translateX(0);
    }

    /* ==================== éŸ³ä¹å¯è§†åŒ– ==================== */
    .audio-visualizer {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
    }

    /* ==================== æç¤ºæ–‡å­— ==================== */
    .hint {
      position: absolute;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.4);
      font-size: 11px;
      letter-spacing: 4px;
      text-transform: uppercase;
      pointer-events: none;
      z-index: 100;
      white-space: nowrap;
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      animation: fadeIn 1s ease 0.5s both;
    }

    /* ==================== Toastæç¤º ==================== */
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      background: var(--glass-bg);
      backdrop-filter: blur(30px);
      color: var(--text-primary);
      padding: 18px 36px;
      border-radius: 20px;
      font-size: 15px;
      font-weight: 500;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      border: 1px solid var(--glass-border);
      box-shadow:
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 40px rgba(78, 205, 196, 0.3);
      letter-spacing: 0.5px;
    }

    .toast.show {
      animation: toastAnim 2.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    @keyframes toastAnim {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }
      15% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      85% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.95);
      }
    }

    /* ==================== åŠ¨ç”»æ•ˆæœ ==================== */
    @keyframes slideInLeft {
      from {
        opacity: 0;
        transform: translateX(-30px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(30px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        filter: drop-shadow(0 4px 12px rgba(255, 255, 255, 0.3));
      }
      50% {
        transform: scale(1.05);
        filter: drop-shadow(0 6px 16px rgba(255, 255, 255, 0.5));
      }
    }

    /* ==================== å“åº”å¼è®¾è®¡ ==================== */
    @media (max-width: 1024px) {
      .shortcuts-panel {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .top-bar {
        padding: 0 15px;
        height: 70px;
      }

      .logo {
        padding: 10px 16px;
      }

      .logo-icon {
        width: 36px;
        height: 36px;
        font-size: 20px;
      }

      .logo-title {
        font-size: 14px;
      }

      .emotion-indicator {
        top: 85px;
        left: 15px;
        padding: 12px 18px;
        gap: 12px;
      }

      .emotion-icon {
        font-size: 30px;
      }

      .emotion-name {
        font-size: 15px;
      }

      .emotion-dock {
        bottom: 25px;
        padding: 12px 16px;
        gap: 10px;
      }

      .emotion-btn {
        width: 46px;
        height: 46px;
        font-size: 22px;
      }

      .control-panel {
        bottom: 25px;
        right: 15px;
        gap: 10px;
      }

      .btn-control {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .btn-control::after {
        display: none;
      }

      .hint {
        bottom: 120px;
        padding: 8px 16px;
        font-size: 10px;
        letter-spacing: 3px;
      }

      .toast {
        padding: 16px 28px;
        font-size: 14px;
      }
    }

    @media (max-width: 480px) {
      .emotion-indicator {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
        padding: 10px 14px;
      }

      .emotion-icon {
        font-size: 24px;
      }

      .emotion-dock {
        padding: 10px 14px;
        gap: 8px;
        border-radius: 20px;
      }

      .emotion-btn {
        width: 42px;
        height: 42px;
        font-size: 20px;
      }
    }

    /* ==================== æ·±è‰²æ¨¡å¼ä¼˜åŒ– ==================== */
    @media (prefers-color-scheme: dark) {
      html, body {
        background: linear-gradient(135deg, #050508 0%, #0f0f1a 100%);
      }
    }

    /* ==================== åŠ è½½åŠ¨ç”» ==================== */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: #0a0a0f;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    .loading-overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--primary-glow);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- åŠ è½½é®ç½© -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>

  <div class="container" id="container">
    <!-- Canvasç”»å¸ƒ -->
    <canvas id="particleCanvas"></canvas>

    <!-- éŸ³ä¹å¯è§†åŒ–ç”»å¸ƒ -->
    <canvas id="audioVisualizer" class="audio-visualizer"></canvas>

    <!-- æ–‡å­—ç²’å­å±‚ -->
    <div class="text-layer" id="textLayer"></div>

    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="top-bar">
      <!-- Logo -->
      <div class="logo">
        <div class="logo-icon">âœ¨</div>
        <div class="logo-text">
          <div class="logo-title">æƒ…ç»ªæ˜Ÿäº‘</div>
          <div class="logo-subtitle">Emotion Nebula</div>
        </div>
      </div>

      <!-- å¿«æ·é”®é¢æ¿ -->
      <div class="shortcuts-panel">
        <div class="shortcuts-grid">
          <div class="shortcut-item"><kbd>1</kbd>-<kbd>5</kbd> æƒ…ç»ªåˆ‡æ¢</div>
          <div class="shortcut-item"><kbd>M</kbd> éŸ³ä¹å¼€å…³</div>
          <div class="shortcut-item"><kbd>S</kbd> ä¿å­˜å›¾ç‰‡</div>
          <div class="shortcut-item"><kbd>R</kbd> é‡ç½®ç”»å¸ƒ</div>
          <div class="shortcut-item"><kbd>Space</kbd> æš‚åœæ’­æ”¾</div>
          <div class="shortcut-item"><kbd>æ»šè½®</kbd> ç¼©æ”¾ç²’å­</div>
        </div>
      </div>
    </div>

    <!-- æƒ…ç»ªæŒ‡ç¤ºå™¨ -->
    <div class="emotion-indicator">
      <span class="emotion-icon" id="emotionIcon">ğŸ˜Š</span>
      <div class="emotion-info">
        <div class="emotion-name" id="emotionName">å¿«ä¹æ¨¡å¼</div>
        <div class="emotion-desc">Happy Mode</div>
      </div>
    </div>

    <!-- æƒ…ç»ªé€‰æ‹©å™¨ -->
    <div class="emotion-dock">
      <button class="emotion-btn active" data-emotion="happy" data-tooltip="å¿«ä¹">ğŸ˜Š</button>
      <button class="emotion-btn" data-emotion="sad" data-tooltip="æ‚²ä¼¤">ğŸ˜¢</button>
      <button class="emotion-btn" data-emotion="angry" data-tooltip="æ„¤æ€’">ğŸ˜ </button>
      <button class="emotion-btn" data-emotion="calm" data-tooltip="å¹³é™">ğŸ˜Œ</button>
      <button class="emotion-btn" data-emotion="energetic" data-tooltip="æ´»åŠ›">âš¡</button>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
      <button class="btn-control" id="btnMusic" data-tooltip="éŸ³ä¹ (M)">ğŸµ</button>
      <button class="btn-control" id="btnSave" data-tooltip="ä¿å­˜ (S)">ğŸ“·</button>
      <button class="btn-control" id="btnReset" data-tooltip="é‡ç½® (R)">ğŸ”„</button>
      <button class="btn-control" id="btnPause" data-tooltip="æš‚åœ (Space)">â¸ï¸</button>
    </div>

    <!-- æç¤ºæ–‡å­— -->
    <div class="hint">ç‚¹å‡»Â·æ‹–åŠ¨Â·æ»šè½®ç¼©æ”¾Â·é•¿æŒ‰ä¿å­˜</div>

    <!-- Toastå®¹å™¨ -->
    <div class="toast" id="toast"></div>
  </div>

  <script>
    /**
     * ============================================
     * æƒ…ç»ªæ˜Ÿäº‘ Pro - å¢å¼ºç‰ˆç²’å­ç³»ç»Ÿ
     * ============================================
     * åŠŸèƒ½ç‰¹æ€§ï¼š
     * - 5ç§æƒ…ç»ªæ¨¡å¼ï¼Œæ¯ç§ç‹¬ç‰¹çš„ç²’å­è¡¨ç°
     * - éŸ³é¢‘èŠ‚å¥å“åº”
     * - ç²’å­èåˆæ•ˆæœ
     * - é«˜çº§äº¤äº’ï¼ˆåŒæŒ‡ç¼©æ”¾ã€å¿«æ·é”®ç­‰ï¼‰
     * - PWAæ”¯æŒï¼Œç¦»çº¿å¯ç”¨
     *
     * æ‰©å±•æ¥å£ï¼š
     * - exportGIF() - GIFå¯¼å‡º
     * - voiceControl() - è¯­éŸ³äº¤äº’
     * - customEmotion() - è‡ªå®šä¹‰æƒ…ç»ª
     * ============================================
     */

    // ========== æƒ…ç»ªæ¨¡å¼é…ç½® ==========
    const EMOTION_CONFIGS = {
      happy: {
        name: 'å¿«ä¹æ¨¡å¼',
        icon: 'ğŸ˜Š',
        desc: 'Happy',
        colors: ['#FFD93D', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'],
        speedMultiplier: 1.5,
        sizeMultiplier: 1.2,
        shapes: ['circle', 'star'],
        trailLength: 15,
        bounceElasticity: 0.9,
        rotationSpeed: 0.05,
        lifeDecay: 0.001,
        particleCount: 60,
        backgroundColor: 'rgba(255, 220, 100, 0.03)'
      },
      sad: {
        name: 'æ‚²ä¼¤æ¨¡å¼',
        icon: 'ğŸ˜¢',
        desc: 'Sad',
        colors: ['#6B7280', '#9CA3AF', '#D1D5DB', '#60A5FA', '#818CF8'],
        speedMultiplier: 0.5,
        sizeMultiplier: 0.8,
        shapes: ['circle', 'teardrop'],
        trailLength: 30,
        bounceElasticity: 0.3,
        rotationSpeed: 0.01,
        lifeDecay: 0.0005,
        particleCount: 40,
        backgroundColor: 'rgba(100, 120, 150, 0.03)'
      },
      angry: {
        name: 'æ„¤æ€’æ¨¡å¼',
        icon: 'ğŸ˜ ',
        desc: 'Angry',
        colors: ['#EF4444', '#F97316', '#DC2626', '#B91C1C', '#FCA5A5'],
        speedMultiplier: 2.5,
        sizeMultiplier: 1.5,
        shapes: ['triangle', 'square', 'spike'],
        trailLength: 10,
        bounceElasticity: 1.2,
        rotationSpeed: 0.15,
        lifeDecay: 0.003,
        particleCount: 70,
        backgroundColor: 'rgba(220, 50, 50, 0.04)'
      },
      calm: {
        name: 'å¹³é™æ¨¡å¼',
        icon: 'ğŸ˜Œ',
        desc: 'Calm',
        colors: ['#A7F3D0', '#6EE7B7', '#34D399', '#10B981', '#99F6E4'],
        speedMultiplier: 0.7,
        sizeMultiplier: 1.0,
        shapes: ['circle', 'oval'],
        trailLength: 25,
        bounceElasticity: 0.5,
        rotationSpeed: 0.02,
        lifeDecay: 0.0008,
        particleCount: 45,
        backgroundColor: 'rgba(100, 200, 150, 0.02)'
      },
      energetic: {
        name: 'æ´»åŠ›æ¨¡å¼',
        icon: 'âš¡',
        desc: 'Energetic',
        colors: ['#FBBF24', '#F59E0B', '#FCD34D', '#EAB308', '#FEF3C7'],
        speedMultiplier: 3.0,
        sizeMultiplier: 0.9,
        shapes: ['star', 'diamond', 'triangle'],
        trailLength: 8,
        bounceElasticity: 1.0,
        rotationSpeed: 0.2,
        lifeDecay: 0.004,
        particleCount: 80,
        backgroundColor: 'rgba(255, 200, 50, 0.03)'
      }
    };

    // ========== æŠ½è±¡æ–‡å­—ç´ æ ==========
    const TEXT_SOURCES = {
      happy: ['å¿«ä¹', 'é—ªè€€', 'ç»½æ”¾', 'æ¬¢ç¬‘', 'é˜³å…‰', 'âœ¨', 'â­', 'ğŸŒŸ', 'å¹¸ç¦', 'ç”œèœœ'],
      sad: ['æ³ªæ°´', 'å¯‚é™', 'å­¤å•', 'é£˜è½', 'ğŸŒ§', 'ğŸ’§', 'ç°æš—', 'æµé€', 'å›å¿†'],
      angry: ['ç‡ƒçƒ§', 'çˆ†å‘', 'æ€’ç«', 'ğŸ’¥', 'ğŸ”¥', 'æ„¤æ€’', 'å†²åŠ¨', 'ç‹‚çƒ­'],
      calm: ['å®é™', 'å®‰è¯¦', 'å¹³å’Œ', 'æµåŠ¨', 'ğŸŒŠ', 'â˜ï¸', 'å‘¼å¸', 'æ¸…æ¾ˆ'],
      energetic: ['æ´»åŠ›', 'èƒ½é‡', 'æ¿€è¡', 'âš¡', 'ğŸ’«', 'ç‡ƒçƒ§', 'é£è·ƒ', 'çªç ´']
    };

    // ========== ä¸»ç±»ï¼šEmotionNebula ==========
    class EmotionNebula {
      constructor() {
        // Canvasè®¾ç½®
        this.canvas = document.getElementById('particleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.visualizerCanvas = document.getElementById('audioVisualizer');
        this.visualizerCtx = this.visualizerCanvas.getContext('2d');
        this.container = document.getElementById('container');
        this.textLayer = document.getElementById('textLayer');

        // ç²’å­ç³»ç»Ÿ
        this.particles = [];
        this.textParticles = [];
        this.textParticleId = 0;

        // å½“å‰æƒ…ç»ª
        this.currentEmotion = 'happy';
        this.emotionConfig = EMOTION_CONFIGS.happy;

        // å°ºå¯¸
        this.width = 0;
        this.height = 0;
        this.globalSizeMultiplier = 1.0;

        // éŸ³é¢‘
        this.audio = null;
        this.audioContext = null;
        this.analyser = null;
        this.dataArray = null;
        this.isPlayingMusic = false;
        this.audioLevel = 0; // éŸ³é¢‘å¼ºåº¦ï¼ˆ0-1ï¼‰

        // åŠ¨ç”»
        this.animationId = null;
        this.isPaused = false;

        // äº¤äº’çŠ¶æ€
        this.lastTouchPos = { x: 0, y: 0 };
        this.touchStartTime = 0;
        this.longPressTimer = null;
        this.lastTouchTime = 0;
        this.touchSpeed = 0;
        this.isPinching = false;
        this.pinchStartDistance = 0;
        this.pinchStartSize = 1.0;

        // åˆå§‹åŒ–
        this.init();
      }

      init() {
        this.resize();
        this.setupCanvas();
        this.initParticles();
        this.bindEvents();
        this.bindEmotionButtons();
        this.startAnimation();
        this.spawnTextParticles();
        this.setupAudioVisualizer();

        // éšè—åŠ è½½åŠ¨ç”»
        setTimeout(() => {
          document.getElementById('loadingOverlay').classList.add('hidden');
        }, 800);

        // çª—å£å¤§å°æ”¹å˜
        window.addEventListener('resize', () => this.resize());
      }

      // ========== Canvasè®¾ç½® ==========
      resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.visualizerCanvas.width = this.width;
        this.visualizerCanvas.height = 100;
      }

      setupCanvas() {
        // è®¾ç½®åˆå§‹èƒŒæ™¯
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.width, this.height);
      }

      // ========== ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ==========
      /**
       * åˆ›å»ºç²’å­ - æ ¸å¿ƒæ–¹æ³•
       * @param {number} x - Xåæ ‡
       * @param {number} y - Yåæ ‡
       * @param {object} options - å¯é€‰å‚æ•° {size, color, shape, speed}
       * @returns {object} ç²’å­å¯¹è±¡
       */
      createParticle(x, y, options = {}) {
        const config = this.emotionConfig;
        const shapes = config.shapes;
        const colors = config.colors;

        const size = (options.size || Math.random() * 20 + 5) *
                     config.sizeMultiplier *
                     this.globalSizeMultiplier;
        const color = options.color || colors[Math.floor(Math.random() * colors.length)];
        const shape = options.shape || shapes[Math.floor(Math.random() * shapes.length)];
        const speed = config.speedMultiplier;

        return {
          x: x ?? Math.random() * this.width,
          y: y ?? Math.random() * this.height,
          vx: (Math.random() - 0.5) * 3 * speed,
          vy: (Math.random() - 0.5) * 3 * speed,
          size: size,
          targetSize: size,
          currentSize: 0,
          color: color,
          shape: shape,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * config.rotationSpeed,
          life: 1,
          decay: (Math.random() * 0.002 + config.lifeDecay),
          alpha: Math.random() * 0.5 + 0.3,
          trail: [],
          maxTrailLength: config.trailLength
        };
      }

      /**
       * åˆå§‹åŒ–ç²’å­ç¾¤
       */
      initParticles() {
        const config = this.emotionConfig;
        const count = config.particleCount;

        for (let i = 0; i < count; i++) {
          this.particles.push(this.createParticle());
        }
      }

      /**
       * æ›´æ–°ç²’å­çŠ¶æ€
       */
      updateParticles() {
        const config = this.emotionConfig;

        this.particles = this.particles.filter(p => {
          // éŸ³é¢‘å“åº” - ç²’å­å¤§å°éšéŸ³ä¹èŠ‚å¥å˜åŒ–
          if (this.audioLevel > 0) {
            p.currentSize = p.targetSize * (1 + this.audioLevel * 0.5);
          }

          // æ›´æ–°ä½ç½®
          p.x += p.vx;
          p.y += p.vy;

          // è¾¹ç•Œå¼¹æ€§åå¼¹ - ä¸åŒæƒ…ç»ªä¸åŒå¼¹æ€§
          const elasticity = config.bounceElasticity;
          if (p.x < 0) {
            p.x = 0;
            p.vx *= -elasticity;
          }
          if (p.x > this.width) {
            p.x = this.width;
            p.vx *= -elasticity;
          }
          if (p.y < 0) {
            p.y = 0;
            p.vy *= -elasticity;
          }
          if (p.y > this.height) {
            p.y = this.height;
            p.vy *= -elasticity;
          }

          // æ—‹è½¬æ›´æ–°
          p.rotation += p.rotationSpeed;

          // æ¸å…¥æ•ˆæœ
          if (p.currentSize < p.targetSize && this.audioLevel === 0) {
            p.currentSize += 0.5;
          }

          // è®°å½•è½¨è¿¹ - è½¨è¿¹é•¿åº¦éšæƒ…ç»ªå˜åŒ–
          p.trail.push({ x: p.x, y: p.y, alpha: 1.0 });
          if (p.trail.length > p.maxTrailLength) {
            p.trail.shift();
          }

          // è½¨è¿¹æ¸éš
          p.trail.forEach((point, i) => {
            point.alpha = i / p.trail.length;
          });

          // ç²’å­èåˆæ•ˆæœ - è¿‘è·ç¦»ç²’å­ç›¸äº’å¸å¼•
          this.particles.forEach(other => {
            if (other === p) return;
            const dist = Math.hypot(p.x - other.x, p.y - other.y);
            if (dist < 50 && dist > 10) {
              const force = 0.01;
              p.vx += (other.x - p.x) / dist * force;
              p.vy += (other.y - p.y) / dist * force;
            }
          });

          // ç”Ÿå‘½è¡°å‡
          p.life -= p.decay;

          return p.life > 0;
        });

        // ç»´æŒæœ€å°ç²’å­æ•°
        while (this.particles.length < config.particleCount * 0.6) {
          this.particles.push(this.createParticle());
        }
      }

      /**
       * ç»˜åˆ¶ç²’å­
       */
      drawParticles() {
        const ctx = this.ctx;
        const config = this.emotionConfig;

        // åŠ¨æ€èƒŒæ™¯æ¸å˜ - åŸºäºç²’å­å¹³å‡é¢œè‰²
        const avgColor = this.getAverageParticleColor();
        const bgColor = this.interpolateColor('#0a0a0f', avgColor, 0.1);
        ctx.fillStyle = this.hexToRgba(bgColor, 0.08);
        ctx.fillRect(0, 0, this.width, this.height);

        // ç»˜åˆ¶æ¯ä¸ªç²’å­
        this.particles.forEach(p => {
          ctx.save();

          // ç»˜åˆ¶è½¨è¿¹ - æ¸éšé€æ˜æ•ˆæœ
          if (p.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let i = 1; i < p.trail.length; i++) {
              ctx.lineTo(p.trail[i].x, p.trail[i].y);
            }
            ctx.strokeStyle = p.color;
            ctx.lineWidth = p.size * 0.3;
            ctx.globalAlpha = p.alpha * p.life * 0.4;

            // è½¨è¿¹æ¸å˜
            const gradient = ctx.createLinearGradient(
              p.trail[0].x, p.trail[0].y,
              p.trail[p.trail.length - 1].x, p.trail[p.trail.length - 1].y
            );
            gradient.addColorStop(0, `rgba(0,0,0,0)`);
            gradient.addColorStop(1, p.color);
            ctx.strokeStyle = gradient;

            ctx.stroke();
          }

          // ç»˜åˆ¶ç²’å­
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.globalAlpha = p.alpha * p.life;
          ctx.fillStyle = p.color;

          this.drawShape(ctx, p.shape, p.currentSize);

          ctx.restore();
        });

        // æ›´æ–°å®¹å™¨èƒŒæ™¯è‰²
        this.updateBackgroundColor(avgColor);
      }

      /**
       * ç»˜åˆ¶ä¸åŒå½¢çŠ¶
       */
      drawShape(ctx, shape, size) {
        switch (shape) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'triangle':
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.866, size * 0.5);
            ctx.lineTo(-size * 0.866, size * 0.5);
            ctx.closePath();
            ctx.fill();
            break;

          case 'square':
            ctx.fillRect(-size / 2, -size / 2, size, size);
            break;

          case 'star':
            this.drawStar(ctx, 5, size, size / 2);
            break;

          case 'diamond':
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.7, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size * 0.7, 0);
            ctx.closePath();
            ctx.fill();
            break;

          case 'teardrop':
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.bezierCurveTo(size, -size * 0.3, size, size * 0.5, 0, size);
            ctx.bezierCurveTo(-size, size * 0.5, -size, -size * 0.3, 0, -size);
            ctx.fill();
            break;

          case 'oval':
            ctx.beginPath();
            ctx.ellipse(0, 0, size * 0.6, size, 0, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'spike':
            this.drawStar(ctx, 8, size, size * 0.3);
            break;

          default:
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
        }
      }

      /**
       * ç»˜åˆ¶æ˜Ÿå½¢
       */
      drawStar(ctx, points, outerRadius, innerRadius) {
        ctx.beginPath();
        for (let i = 0; i < points * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      /**
       * ç²’å­çˆ†å‘ - ä¸­å¿ƒå¤§çˆ†å‘/è¾¹ç¼˜å°çˆ†å‘
       */
      burstParticles(x, y, isCenter) {
        const count = isCenter ? 20 : 8;
        const speed = isCenter ? 6 : 3;

        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
          const particleSpeed = speed * (0.5 + Math.random());
          const particle = this.createParticle(x, y, {
            size: Math.random() * 15 + 5,
            color: this.emotionConfig.colors[Math.floor(Math.random() * this.emotionConfig.colors.length)]
          });
          particle.vx = Math.cos(angle) * particleSpeed;
          particle.vy = Math.sin(angle) * particleSpeed;
          particle.decay = 0.01;
          this.particles.push(particle);
        }

        // éœ‡åŠ¨åé¦ˆ
        this.vibrate(isCenter ? [50, 30, 50] : 30);
      }

      /**
       * åˆ‡æ¢æƒ…ç»ªæ¨¡å¼
       */
      setEmotion(emotion) {
        if (!EMOTION_CONFIGS[emotion]) return;

        this.currentEmotion = emotion;
        this.emotionConfig = EMOTION_CONFIGS[emotion];

        // æ›´æ–°UI
        document.getElementById('emotionIcon').textContent = this.emotionConfig.icon;
        document.getElementById('emotionName').textContent = this.emotionConfig.name;
        document.querySelector('.emotion-desc').textContent = this.emotionConfig.desc;

        document.querySelectorAll('.emotion-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.emotion === emotion);
        });

        // æ¸…ç©ºç°æœ‰ç²’å­ï¼Œé‡æ–°ç”Ÿæˆ
        this.particles = [];
        this.initParticles();

        // æ¸…ç©ºæ–‡å­—ç²’å­
        this.textParticles = [];
        this.textLayer.innerHTML = '';

        this.showToast(`å·²åˆ‡æ¢è‡³${this.emotionConfig.name}`);
      }

      /**
       * æ ¹æ®æ‹–åŠ¨é€Ÿåº¦è‡ªåŠ¨åˆ‡æ¢æƒ…ç»ª
       */
      autoSwitchEmotionBySpeed() {
        if (this.touchSpeed > 15) {
          if (this.currentEmotion !== 'energetic') {
            this.setEmotion('energetic');
          }
        } else if (this.touchSpeed > 8) {
          if (this.currentEmotion !== 'angry') {
            this.setEmotion('angry');
          }
        } else if (this.touchSpeed < 2) {
          if (this.currentEmotion !== 'calm') {
            this.setEmotion('calm');
          }
        }
      }

      // ========== æ–‡å­—ç²’å­ç³»ç»Ÿ ==========
      spawnTextParticles() {
        setInterval(() => {
          if (this.textParticles.length < 8 && !this.isPaused) {
            const texts = TEXT_SOURCES[this.currentEmotion] || TEXT_SOURCES.happy;
            const text = texts[Math.floor(Math.random() * texts.length)];
            const color = this.emotionConfig.colors[
              Math.floor(Math.random() * this.emotionConfig.colors.length)
            ];

            const textParticle = {
              id: this.textParticleId++,
              text: text,
              x: Math.random() * (this.width - 100) + 50,
              y: Math.random() * (this.height - 100) + 50,
              vx: (Math.random() - 0.5) * this.emotionConfig.speedMultiplier,
              vy: (Math.random() - 0.5) * this.emotionConfig.speedMultiplier,
              color: color,
              size: (Math.random() * 20 + 14) * this.globalSizeMultiplier,
              opacity: 0,
              targetOpacity: Math.random() * 0.6 + 0.4,
            };

            this.textParticles.push(textParticle);
            this.createTextElement(textParticle);
          }
        }, 3000);
      }

      createTextElement(particle) {
        const el = document.createElement('div');
        el.className = 'text-particle';
        el.id = `text-${particle.id}`;
        el.textContent = particle.text;
        el.style.color = particle.color;
        el.style.fontSize = `${particle.size}px`;
        this.textLayer.appendChild(el);
      }

      updateTextParticles() {
        this.textParticles = this.textParticles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;

          // è¾¹ç•Œæ£€æµ‹
          if (p.x < 0 || p.x > this.width) p.vx *= -1;
          if (p.y < 0 || p.y > this.height) p.vy *= -1;

          // æ¸å…¥æ•ˆæœ
          if (p.opacity < p.targetOpacity) {
            p.opacity = Math.min(p.opacity + 0.02, p.targetOpacity);
          }

          // æ›´æ–°DOM
          const el = document.getElementById(`text-${p.id}`);
          if (el) {
            el.style.left = `${p.x}px`;
            el.style.top = `${p.y}px`;
            el.style.opacity = p.opacity;
          }

          return true;
        });
      }

      // ========== åŠ¨ç”»å¾ªç¯ ==========
      startAnimation() {
        const animate = () => {
          if (!this.isPaused) {
            this.updateParticles();
            this.drawParticles();
            this.updateTextParticles();
            this.updateAudioLevel();
            this.drawAudioVisualizer();
          }
          this.animationId = requestAnimationFrame(animate);
        };
        animate();
      }

      // ========== éŸ³é¢‘ç³»ç»Ÿ ==========
      setupAudio() {
        if (this.audio) return;

        this.audio = new Audio();
        this.audio.loop = true;
        this.audio.volume = 0.3;
        this.audio.crossOrigin = 'anonymous';

        // ç¯å¢ƒéŸ³ä¹èµ„æºï¼ˆå…è´¹ç‰ˆæƒï¼‰
        const audioSources = {
          happy: 'https://cdn.pixabay.com/download/audio/2022/05/27/audio_1808fbf07a.mp3',
          sad: 'https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3',
          angry: 'https://cdn.pixabay.com/download/audio/2022/01/18/audio_d0a13f69d2.mp3',
          calm: 'https://cdn.pixabay.com/download/audio/2021/08/04/audio_12b0c7443c.mp3',
          energetic: 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_ba8704089c.mp3'
        };

        this.audio.src = audioSources[this.currentEmotion] || audioSources.happy;

        // è®¾ç½®éŸ³é¢‘åˆ†æå™¨
        this.setupAudioAnalyser();

        this.audio.addEventListener('ended', () => {
          if (this.isPlayingMusic) {
            this.audio.currentTime = 0;
            this.audio.play();
          }
        });
      }

      setupAudioAnalyser() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 256;
          this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

          // è¿æ¥éŸ³é¢‘æº
          const source = this.audioContext.createMediaElementSource(this.audio);
          source.connect(this.analyser);
          this.analyser.connect(this.audioContext.destination);
        }
      }

      setupAudioVisualizer() {
        // åˆå§‹åŒ–å¯è§†åŒ–ç”»å¸ƒ
        this.visualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.visualizerCtx.fillRect(0, 0, this.width, 100);
      }

      updateAudioLevel() {
        if (this.analyser && this.isPlayingMusic) {
          this.analyser.getByteFrequencyData(this.dataArray);
          const average = this.dataArray.reduce((a, b) => a + b, 0) / this.dataArray.length;
          this.audioLevel = average / 255; // å½’ä¸€åŒ–åˆ° 0-1
        } else {
          this.audioLevel = 0;
        }
      }

      drawAudioVisualizer() {
        if (!this.analyser || !this.isPlayingMusic) return;

        const ctx = this.visualizerCtx;
        const width = this.width;
        const height = 100;
        const bufferLength = this.analyser.frequencyBinCount;
        const barWidth = (width / bufferLength) * 2.5;
        let x = 0;

        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = (this.dataArray[i] / 255) * height;

          // ä½¿ç”¨æƒ…ç»ªé…è‰²
          const colorIndex = Math.floor((i / bufferLength) * this.emotionConfig.colors.length);
          ctx.fillStyle = this.emotionConfig.colors[colorIndex] || '#fff';

          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }

      toggleMusic() {
        if (!this.audio) {
          this.setupAudio();
        }

        if (this.isPlayingMusic) {
          this.audio.pause();
          this.isPlayingMusic = false;
          document.getElementById('btnMusic').textContent = 'ğŸµ';
        } else {
          // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆæµè§ˆå™¨å¯èƒ½è‡ªåŠ¨æš‚åœï¼‰
          if (this.audioContext && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
          }

          this.audio.play().then(() => {
            this.isPlayingMusic = true;
            document.getElementById('btnMusic').textContent = 'â¸';
          }).catch(err => {
            console.log('éŸ³é¢‘æ’­æ”¾éœ€è¦ç”¨æˆ·äº¤äº’:', err);
          });
        }

        this.vibrate(30);
      }

      // ========== äº‹ä»¶ç»‘å®š ==========
      bindEvents() {
        const canvas = this.canvas;

        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', () => this.onTouchEnd());

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        canvas.addEventListener('mouseup', () => this.onMouseEnd());
        canvas.addEventListener('wheel', (e) => this.onWheel(e));

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => this.onKeyDown(e));

        // æ§åˆ¶æŒ‰é’®
        document.getElementById('btnMusic').addEventListener('click', () => this.toggleMusic());
        document.getElementById('btnSave').addEventListener('click', () => this.saveImage());
        document.getElementById('btnReset').addEventListener('click', () => this.resetCanvas());
        document.getElementById('btnPause').addEventListener('click', () => this.togglePause());

        // é˜²æ­¢å³é”®èœå•
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      }

      bindEmotionButtons() {
        document.querySelectorAll('.emotion-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            this.setEmotion(btn.dataset.emotion);
            this.vibrate(30);
          });
        });
      }

      getEventPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      // è§¦æ‘¸äº‹ä»¶
      onTouchStart(e) {
        e.preventDefault();

        // åŒæŒ‡ç¼©æ”¾
        if (e.touches.length === 2) {
          this.isPinching = true;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          this.pinchStartDistance = Math.hypot(dx, dy);
          this.pinchStartSize = this.globalSizeMultiplier;
          return;
        }

        const pos = this.getEventPos(e);
        this.lastTouchPos = pos;
        this.touchStartTime = Date.now();
        this.lastTouchTime = Date.now();

        // åˆ¤æ–­æ˜¯å¦ä¸­å¿ƒç‚¹å‡»
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const distToCenter = Math.hypot(pos.x - centerX, pos.y - centerY);
        const isCenter = distToCenter < Math.min(this.width, this.height) * 0.2;

        this.burstParticles(pos.x, pos.y, isCenter);

        // é•¿æŒ‰æ£€æµ‹
        this.longPressTimer = setTimeout(() => {
          this.saveImage();
        }, 800);
      }

      onTouchMove(e) {
        e.preventDefault();

        // åŒæŒ‡ç¼©æ”¾
        if (e.touches.length === 2 && this.isPinching) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const currentDistance = Math.hypot(dx, dy);
          const scale = currentDistance / this.pinchStartDistance;
          this.globalSizeMultiplier = Math.max(0.3, Math.min(3.0, this.pinchStartSize * scale));

          // æ›´æ–°ç°æœ‰ç²’å­å¤§å°
          this.particles.forEach(p => {
            p.targetSize = p.size * this.globalSizeMultiplier;
          });

          return;
        }

        const pos = this.getEventPos(e);
        const currentTime = Date.now();
        const dt = currentTime - this.lastTouchTime;
        const dist = Math.hypot(pos.x - this.lastTouchPos.x, pos.y - this.lastTouchPos.y);

        // è®¡ç®—æ‹–åŠ¨é€Ÿåº¦
        this.touchSpeed = dt > 0 ? dist / dt * 1000 : 0;
        this.lastTouchTime = currentTime;

        // æ ¹æ®é€Ÿåº¦è‡ªåŠ¨åˆ‡æ¢æƒ…ç»ª
        this.autoSwitchEmotionBySpeed();

        const dx = pos.x - this.lastTouchPos.x;
        const dy = pos.y - this.lastTouchPos.y;

        // å½±å“é™„è¿‘ç²’å­
        this.particles.forEach(p => {
          const distance = Math.hypot(p.x - pos.x, p.y - pos.y);
          if (distance < 150) {
            p.vx += dx * 0.02;
            p.vy += dy * 0.02;
          }
        });

        this.lastTouchPos = pos;
      }

      onTouchEnd() {
        if (this.isPinching) {
          this.isPinching = false;
        }

        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }

        // é‡ç½®é€Ÿåº¦
        setTimeout(() => {
          this.touchSpeed = 0;
        }, 500);
      }

      // é¼ æ ‡äº‹ä»¶
      onMouseDown(e) {
        const pos = { x: e.clientX, y: e.clientY };
        this.lastTouchPos = pos;
        this.touchStartTime = Date.now();

        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const distToCenter = Math.hypot(pos.x - centerX, pos.y - centerY);
        const isCenter = distToCenter < Math.min(this.width, this.height) * 0.2;

        this.burstParticles(pos.x, pos.y, isCenter);
      }

      onMouseMove(e) {
        if (e.buttons === 1) {
          const pos = { x: e.clientX, y: e.clientY };
          const dx = pos.x - this.lastTouchPos.x;
          const dy = pos.y - this.lastTouchPos.y;

          this.particles.forEach(p => {
            const dist = Math.hypot(p.x - pos.x, p.y - pos.y);
            if (dist < 150) {
              p.vx += dx * 0.02;
              p.vy += dy * 0.02;
            }
          });

          this.lastTouchPos = pos;
        }
      }

      onMouseEnd() {}

      onWheel(e) {
        e.preventDefault();
        // é¼ æ ‡æ»šè½®ç¼©æ”¾
        const delta = e.deltaY > 0 ? 0.95 : 1.05;
        this.globalSizeMultiplier = Math.max(0.3, Math.min(3.0, this.globalSizeMultiplier * delta));

        // æ›´æ–°ç°æœ‰ç²’å­
        this.particles.forEach(p => {
          p.targetSize = p.size * this.globalSizeMultiplier;
        });
      }

      // é”®ç›˜å¿«æ·é”®
      onKeyDown(e) {
        const key = e.key.toLowerCase();

        switch (key) {
          case '1': this.setEmotion('happy'); break;
          case '2': this.setEmotion('sad'); break;
          case '3': this.setEmotion('angry'); break;
          case '4': this.setEmotion('calm'); break;
          case '5': this.setEmotion('energetic'); break;
          case 'm': this.toggleMusic(); break;
          case 's': this.saveImage(); break;
          case 'r': this.resetCanvas(); break;
          case ' ': this.togglePause(); e.preventDefault(); break;
        }
      }

      // ========== åŠŸèƒ½æ–¹æ³• ==========
      saveImage() {
        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }

        this.vibrate([50, 50, 50]);

        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = this.width * 2;
        exportCanvas.height = this.height * 2;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.scale(2, 2);

        exportCtx.fillStyle = '#0a0a0f';
        exportCtx.fillRect(0, 0, this.width, this.height);

        exportCtx.drawImage(this.canvas, 0, 0);

        const link = document.createElement('a');
        link.download = `æƒ…ç»ªæ˜Ÿäº‘_${this.currentEmotion}_${Date.now()}.png`;
        link.href = exportCanvas.toDataURL('image/png');
        link.click();

        this.showToast('å›¾ç‰‡å·²ä¿å­˜');
      }

      resetCanvas() {
        this.vibrate([30, 30]);

        // æ¸…é™¤ç²’å­
        this.particles = [];
        this.textParticles = [];
        this.textLayer.innerHTML = '';

        // éšæœºåˆ‡æ¢æƒ…ç»ª
        const emotions = Object.keys(EMOTION_CONFIGS);
        const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
        this.setEmotion(randomEmotion);

        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.showToast('ç”»å¸ƒå·²é‡ç½®');
      }

      togglePause() {
        this.isPaused = !this.isPaused;
        document.getElementById('btnPause').textContent = this.isPaused ? 'â–¶ï¸' : 'â¸ï¸';
        this.showToast(this.isPaused ? 'å·²æš‚åœ' : 'ç»§ç»­æ’­æ”¾');
        this.vibrate(30);
      }

      vibrate(pattern) {
        if (navigator.vibrate) {
          navigator.vibrate(pattern);
        }
      }

      showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.remove('show');
        void toast.offsetWidth; // è§¦å‘é‡æ’
        toast.classList.add('show');
      }

      // ========== è¾…åŠ©æ–¹æ³• ==========
      getAverageParticleColor() {
        if (this.particles.length === 0) return '#0a0a0f';

        let r = 0, g = 0, b = 0;
        let count = 0;

        this.particles.forEach(p => {
          const rgb = this.hexToRgb(p.color);
          if (rgb) {
            r += rgb.r;
            g += rgb.g;
            b += rgb.b;
            count++;
          }
        });

        if (count === 0) return '#0a0a0f';

        r = Math.round(r / count);
        g = Math.round(g / count);
        b = Math.round(b / count);

        return this.rgbToHex(r, g, b);
      }

      updateBackgroundColor(color) {
        const rgba = this.hexToRgba(color, 0.1);
        this.container.style.background = rgba;
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
          const hex = x.toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        }).join('');
      }

      hexToRgba(hex, alpha) {
        const rgb = this.hexToRgb(hex);
        return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})` : `rgba(0, 0, 0, ${alpha})`;
      }

      interpolateColor(color1, color2, factor) {
        const rgb1 = this.hexToRgb(color1);
        const rgb2 = this.hexToRgb(color2);

        if (!rgb1 || !rgb2) return color1;

        const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
        const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
        const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);

        return this.rgbToHex(r, g, b);
      }

      // ========== æ‰©å±•æ¥å£ ==========
      /**
       * å¯¼å‡ºGIFåŠ¨ç”»ï¼ˆéœ€è¦gif.jsåº“ï¼‰
       * æ‰©å±•ç‚¹ï¼šå¯é›†æˆç¬¬ä¸‰æ–¹åº“å®ç°
       */
      async exportGIF() {
        // TODO: é›†æˆgif.jsæˆ–gifshotåº“
        this.showToast('GIFå¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...');
        console.log('[æ‰©å±•] GIFå¯¼å‡ºæ¥å£å·²é¢„ç•™');
      }

      /**
       * è¯­éŸ³æ§åˆ¶æƒ…ç»ªåˆ‡æ¢
       * æ‰©å±•ç‚¹ï¼šå¯é›†æˆWeb Speech API
       */
      async voiceControl() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          this.showToast('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
          return;
        }

        // TODO: å®ç°è¯­éŸ³è¯†åˆ«é€»è¾‘
        this.showToast('è¯­éŸ³æ§åˆ¶åŠŸèƒ½å¼€å‘ä¸­...');
        console.log('[æ‰©å±•] è¯­éŸ³äº¤äº’æ¥å£å·²é¢„ç•™');
      }

      /**
       * è‡ªå®šä¹‰æƒ…ç»ªé…ç½®
       * æ‰©å±•ç‚¹ï¼šå…è®¸ç”¨æˆ·è‡ªå®šä¹‰æƒ…ç»ªæ¨¡å¼
       */
      customEmotion(config) {
        // TODO: å®ç°è‡ªå®šä¹‰æƒ…ç»ªé€»è¾‘
        console.log('[æ‰©å±•] è‡ªå®šä¹‰æƒ…ç»ªæ¥å£å·²é¢„ç•™', config);
      }
    }

    // ========== å¯åŠ¨åº”ç”¨ ==========
    window.addEventListener('DOMContentLoaded', () => {
      const app = new EmotionNebula();
      window.EmotionNebulaApp = app;

      console.log('%câœ¨ æƒ…ç»ªæ˜Ÿäº‘ Pro', 'color: #4ECDC4; font-size: 24px; font-weight: bold;');
      console.log('%cç²’å­ç³»ç»Ÿå·²å¯åŠ¨ | å¿«æ·é”®: 1-5 æƒ…ç»ª | M éŸ³ä¹ | S ä¿å­˜ | R é‡ç½® | Space æš‚åœ',
                  'color: #888; font-size: 12px;');
    });
  </script>
</body>
</html>
