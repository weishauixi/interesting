<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>æƒ…ç»ªæ˜Ÿäº‘ Pro - æƒ…æ„ŸåŒ–ç²’å­ç³»ç»Ÿ</title>

  <!-- PWA Manifest -->
  <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoi5a2m56We5piT6ZuoIFBybyIsInNob3J0X25hbWUiOiLlrabnpZkiLCJzdGFydF91cmwiOiIuIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzAwMDAwMCIsInRoZW1lX2NvbG9yIjoiIzAwMDAwMCIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDEwMCAxMDAnJTNFJTNDY2lyY2xlIGN4PSc1MCcgY3k9JzUwJyByPSc0NScgZmlsbD0ndXJsKCNncmFkKScanLyUzRSUzQ2RlZnMlM0UlM0NyYWRpYWxHcmFkaWVudCBpZD0nZ3JhZCclM0UlM0NzdG9wIG9mZnNldD0nMCUnIHN0b3AtY29sb3I9JyNGRjZCNkInLyUzRSUzQ3N0b3Agb2Zmc2V0PScxMDAlJyBzdG9wLWNvbG9yPScjNDVFQ0Q0JyUzRSUzQy9yYWRpYWxHcmFkaWVudCUzRSUzQy9kZWZzJTNFJTNDL3N2ZyUzRSIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">

  <style>
    /* ========== å…¨å±€æ ·å¼ ========== */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    /* ========== å®¹å™¨ ========== */
    .container {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background: #000;
      transition: background 2s ease;
    }

    /* ========== Canvasç”»å¸ƒ ========== */
    #particleCanvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    /* ========== æ–‡å­—ç²’å­å±‚ ========== */
    .text-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .text-particle {
      position: absolute;
      font-weight: 300;
      text-shadow: 0 0 10px currentColor;
      transition: opacity 0.3s ease;
      will-change: transform;
      white-space: nowrap;
    }

    /* ========== æƒ…ç»ªæŒ‡ç¤ºå™¨ ========== */
    .emotion-indicator {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .emotion-icon {
      font-size: 24px;
    }

    .emotion-name {
      color: #fff;
      font-size: 14px;
      font-weight: 500;
    }

    /* ========== å¿«æ·é”®æç¤º ========== */
    .shortcuts {
      position: absolute;
      top: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0.4);
      font-size: 11px;
      text-align: right;
      line-height: 1.6;
      z-index: 10;
      display: none;
    }

    @media (min-width: 1024px) {
      .shortcuts { display: block; }
    }

    .shortcuts kbd {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin-right: 5px;
    }

    /* ========== æ§åˆ¶æŒ‰é’® ========== */
    .controls {
      position: absolute;
      bottom: 30px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      z-index: 10;
    }

    .btn-control {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0;
      line-height: 1;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }

    .btn-control:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .btn-control:active {
      transform: scale(0.95);
    }

    /* ========== æƒ…ç»ªé€‰æ‹©å™¨ ========== */
    .emotion-selector {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 15px;
      border-radius: 30px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .emotion-btn {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      border: 2px solid transparent;
      background: rgba(255, 255, 255, 0.1);
      font-size: 22px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .emotion-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .emotion-btn.active {
      border-color: #fff;
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    /* ========== éŸ³ä¹å¯è§†åŒ– ========== */
    .audio-visualizer {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 0;
      opacity: 0.3;
    }

    /* ========== æç¤ºæ–‡å­— ========== */
    .hint {
      position: absolute;
      bottom: 130px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.3);
      font-size: 12px;
      letter-spacing: 3px;
      pointer-events: none;
      z-index: 10;
      white-space: nowrap;
    }

    /* ========== Toastæç¤º ========== */
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      padding: 15px 30px;
      border-radius: 25px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
    }

    .toast.show {
      animation: toastAnim 2s ease forwards;
    }

    @keyframes toastAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }

    /* ========== å“åº”å¼ ========== */
    @media (max-width: 768px) {
      .controls {
        bottom: 20px;
        right: 20px;
        gap: 10px;
      }

      .btn-control {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .emotion-selector {
        bottom: 20px;
        padding: 8px 12px;
        gap: 8px;
      }

      .emotion-btn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }

      .hint {
        bottom: 100px;
        font-size: 10px;
        letter-spacing: 2px;
      }

      .emotion-indicator {
        top: 15px;
        left: 15px;
        padding: 8px 15px;
      }

      .emotion-icon { font-size: 20px; }
      .emotion-name { font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <!-- Canvasç”»å¸ƒ -->
    <canvas id="particleCanvas"></canvas>

    <!-- éŸ³ä¹å¯è§†åŒ–ç”»å¸ƒ -->
    <canvas id="audioVisualizer" class="audio-visualizer"></canvas>

    <!-- æ–‡å­—ç²’å­å±‚ -->
    <div class="text-layer" id="textLayer"></div>

    <!-- æƒ…ç»ªæŒ‡ç¤ºå™¨ -->
    <div class="emotion-indicator">
      <span class="emotion-icon" id="emotionIcon">ğŸ˜Š</span>
      <span class="emotion-name" id="emotionName">Happy</span>
    </div>

    <!-- å¿«æ·é”®æç¤º -->
    <div class="shortcuts">
      <kbd>1</kbd>-<kbd>5</kbd> æƒ…ç»ªåˆ‡æ¢<br>
      <kbd>M</kbd> éŸ³ä¹<br>
      <kbd>S</kbd> ä¿å­˜<br>
      <kbd>R</kbd> é‡ç½®<br>
      <kbd>Space</kbd> æš‚åœ
    </div>

    <!-- æƒ…ç»ªé€‰æ‹©å™¨ -->
    <div class="emotion-selector">
      <button class="emotion-btn active" data-emotion="happy" title="å¿«ä¹">ğŸ˜Š</button>
      <button class="emotion-btn" data-emotion="sad" title="æ‚²ä¼¤">ğŸ˜¢</button>
      <button class="emotion-btn" data-emotion="angry" title="æ„¤æ€’">ğŸ˜ </button>
      <button class="emotion-btn" data-emotion="calm" title="å¹³é™">ğŸ˜Œ</button>
      <button class="emotion-btn" data-emotion="energetic" title="æ´»åŠ›">âš¡</button>
    </div>

    <!-- æ§åˆ¶æŒ‰é’® -->
    <div class="controls">
      <button class="btn-control" id="btnMusic" title="éŸ³ä¹ (M)">ğŸµ</button>
      <button class="btn-control" id="btnSave" title="ä¿å­˜ (S)">ğŸ“·</button>
      <button class="btn-control" id="btnReset" title="é‡ç½® (R)">ğŸ”„</button>
      <button class="btn-control" id="btnPause" title="æš‚åœ (Space)">â¸ï¸</button>
    </div>

    <!-- æç¤ºæ–‡å­— -->
    <div class="hint">ç‚¹å‡»Â·æ‹–åŠ¨Â·åŒæŒ‡ç¼©æ”¾Â·é•¿æŒ‰ä¿å­˜</div>

    <!-- Toastå®¹å™¨ -->
    <div class="toast" id="toast"></div>
  </div>

  <script>
    /**
     * ============================================
     * æƒ…ç»ªæ˜Ÿäº‘ Pro - å¢å¼ºç‰ˆç²’å­ç³»ç»Ÿ
     * ============================================
     * åŠŸèƒ½ç‰¹æ€§ï¼š
     * - 5ç§æƒ…ç»ªæ¨¡å¼ï¼Œæ¯ç§ç‹¬ç‰¹çš„ç²’å­è¡¨ç°
     * - éŸ³é¢‘èŠ‚å¥å“åº”
     * - ç²’å­èåˆæ•ˆæœ
     * - é«˜çº§äº¤äº’ï¼ˆåŒæŒ‡ç¼©æ”¾ã€å¿«æ·é”®ç­‰ï¼‰
     * - PWAæ”¯æŒï¼Œç¦»çº¿å¯ç”¨
     *
     * æ‰©å±•æ¥å£ï¼š
     * - exportGIF() - GIFå¯¼å‡º
     * - voiceControl() - è¯­éŸ³äº¤äº’
     * - customEmotion() - è‡ªå®šä¹‰æƒ…ç»ª
     * ============================================
     */

    // ========== æƒ…ç»ªæ¨¡å¼é…ç½® ==========
    const EMOTION_CONFIGS = {
      happy: {
        name: 'å¿«ä¹',
        icon: 'ğŸ˜Š',
        colors: ['#FFD93D', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'],
        speedMultiplier: 1.5,
        sizeMultiplier: 1.2,
        shapes: ['circle', 'star'],
        trailLength: 15,
        bounceElasticity: 0.9,
        rotationSpeed: 0.05,
        lifeDecay: 0.001,
        particleCount: 60,
        backgroundColor: 'rgba(255, 220, 100, 0.03)'
      },
      sad: {
        name: 'æ‚²ä¼¤',
        icon: 'ğŸ˜¢',
        colors: ['#6B7280', '#9CA3AF', '#D1D5DB', '#60A5FA', '#818CF8'],
        speedMultiplier: 0.5,
        sizeMultiplier: 0.8,
        shapes: ['circle', 'teardrop'],
        trailLength: 30,
        bounceElasticity: 0.3,
        rotationSpeed: 0.01,
        lifeDecay: 0.0005,
        particleCount: 40,
        backgroundColor: 'rgba(100, 120, 150, 0.03)'
      },
      angry: {
        name: 'æ„¤æ€’',
        icon: 'ğŸ˜ ',
        colors: ['#EF4444', '#F97316', '#DC2626', '#B91C1C', '#FCA5A5'],
        speedMultiplier: 2.5,
        sizeMultiplier: 1.5,
        shapes: ['triangle', 'square', 'spike'],
        trailLength: 10,
        bounceElasticity: 1.2,
        rotationSpeed: 0.15,
        lifeDecay: 0.003,
        particleCount: 70,
        backgroundColor: 'rgba(220, 50, 50, 0.04)'
      },
      calm: {
        name: 'å¹³é™',
        icon: 'ğŸ˜Œ',
        colors: ['#A7F3D0', '#6EE7B7', '#34D399', '#10B981', '#99F6E4'],
        speedMultiplier: 0.7,
        sizeMultiplier: 1.0,
        shapes: ['circle', 'oval'],
        trailLength: 25,
        bounceElasticity: 0.5,
        rotationSpeed: 0.02,
        lifeDecay: 0.0008,
        particleCount: 45,
        backgroundColor: 'rgba(100, 200, 150, 0.02)'
      },
      energetic: {
        name: 'æ´»åŠ›',
        icon: 'âš¡',
        colors: ['#FBBF24', '#F59E0B', '#FCD34D', '#EAB308', '#FEF3C7'],
        speedMultiplier: 3.0,
        sizeMultiplier: 0.9,
        shapes: ['star', 'diamond', 'triangle'],
        trailLength: 8,
        bounceElasticity: 1.0,
        rotationSpeed: 0.2,
        lifeDecay: 0.004,
        particleCount: 80,
        backgroundColor: 'rgba(255, 200, 50, 0.03)'
      }
    };

    // ========== æŠ½è±¡æ–‡å­—ç´ æ ==========
    const TEXT_SOURCES = {
      happy: ['å¿«ä¹', 'é—ªè€€', 'ç»½æ”¾', 'æ¬¢ç¬‘', 'é˜³å…‰', 'âœ¨', 'â­', 'ğŸŒŸ', 'å¹¸ç¦', 'ç”œèœœ'],
      sad: ['æ³ªæ°´', 'å¯‚é™', 'å­¤å•', 'é£˜è½', 'ğŸŒ§', 'ğŸ’§', 'ç°æš—', 'æµé€', 'å›å¿†'],
      angry: ['ç‡ƒçƒ§', 'çˆ†å‘', 'æ€’ç«', 'ğŸ’¥', 'ğŸ”¥', 'æ„¤æ€’', 'å†²åŠ¨', 'ç‹‚çƒ­'],
      calm: ['å®é™', 'å®‰è¯¦', 'å¹³å’Œ', 'æµåŠ¨', 'ğŸŒŠ', 'â˜ï¸', 'å‘¼å¸', 'æ¸…æ¾ˆ'],
      energetic: ['æ´»åŠ›', 'èƒ½é‡', 'æ¿€è¡', 'âš¡', 'ğŸ’«', 'ç‡ƒçƒ§', 'é£è·ƒ', 'çªç ´']
    };

    // ========== ä¸»ç±»ï¼šEmotionNebula ==========
    class EmotionNebula {
      constructor() {
        // Canvasè®¾ç½®
        this.canvas = document.getElementById('particleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.visualizerCanvas = document.getElementById('audioVisualizer');
        this.visualizerCtx = this.visualizerCanvas.getContext('2d');
        this.container = document.getElementById('container');
        this.textLayer = document.getElementById('textLayer');

        // ç²’å­ç³»ç»Ÿ
        this.particles = [];
        this.textParticles = [];
        this.textParticleId = 0;

        // å½“å‰æƒ…ç»ª
        this.currentEmotion = 'happy';
        this.emotionConfig = EMOTION_CONFIGS.happy;

        // å°ºå¯¸
        this.width = 0;
        this.height = 0;
        this.globalSizeMultiplier = 1.0;

        // éŸ³é¢‘
        this.audio = null;
        this.audioContext = null;
        this.analyser = null;
        this.dataArray = null;
        this.isPlayingMusic = false;
        this.audioLevel = 0; // éŸ³é¢‘å¼ºåº¦ï¼ˆ0-1ï¼‰

        // åŠ¨ç”»
        this.animationId = null;
        this.isPaused = false;

        // äº¤äº’çŠ¶æ€
        this.lastTouchPos = { x: 0, y: 0 };
        this.touchStartTime = 0;
        this.longPressTimer = null;
        this.lastTouchTime = 0;
        this.touchSpeed = 0;
        this.isPinching = false;
        this.pinchStartDistance = 0;
        this.pinchStartSize = 1.0;

        // åˆå§‹åŒ–
        this.init();
      }

      init() {
        this.resize();
        this.setupCanvas();
        this.initParticles();
        this.bindEvents();
        this.bindEmotionButtons();
        this.startAnimation();
        this.spawnTextParticles();
        this.setupAudioVisualizer();

        // çª—å£å¤§å°æ”¹å˜
        window.addEventListener('resize', () => this.resize());
      }

      // ========== Canvasè®¾ç½® ==========
      resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.visualizerCanvas.width = this.width;
        this.visualizerCanvas.height = 100;
      }

      setupCanvas() {
        // è®¾ç½®åˆå§‹èƒŒæ™¯
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.width, this.height);
      }

      // ========== ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ==========
      /**
       * åˆ›å»ºç²’å­ - æ ¸å¿ƒæ–¹æ³•
       * @param {number} x - Xåæ ‡
       * @param {number} y - Yåæ ‡
       * @param {object} options - å¯é€‰å‚æ•° {size, color, shape, speed}
       * @returns {object} ç²’å­å¯¹è±¡
       */
      createParticle(x, y, options = {}) {
        const config = this.emotionConfig;
        const shapes = config.shapes;
        const colors = config.colors;

        const size = (options.size || Math.random() * 20 + 5) *
                     config.sizeMultiplier *
                     this.globalSizeMultiplier;
        const color = options.color || colors[Math.floor(Math.random() * colors.length)];
        const shape = options.shape || shapes[Math.floor(Math.random() * shapes.length)];
        const speed = config.speedMultiplier;

        return {
          x: x ?? Math.random() * this.width,
          y: y ?? Math.random() * this.height,
          vx: (Math.random() - 0.5) * 3 * speed,
          vy: (Math.random() - 0.5) * 3 * speed,
          size: size,
          targetSize: size,
          currentSize: 0,
          color: color,
          shape: shape,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * config.rotationSpeed,
          life: 1,
          decay: (Math.random() * 0.002 + config.lifeDecay),
          alpha: Math.random() * 0.5 + 0.3,
          trail: [],
          maxTrailLength: config.trailLength
        };
      }

      /**
       * åˆå§‹åŒ–ç²’å­ç¾¤
       */
      initParticles() {
        const config = this.emotionConfig;
        const count = config.particleCount;

        for (let i = 0; i < count; i++) {
          this.particles.push(this.createParticle());
        }
      }

      /**
       * æ›´æ–°ç²’å­çŠ¶æ€
       */
      updateParticles() {
        const config = this.emotionConfig;

        this.particles = this.particles.filter(p => {
          // éŸ³é¢‘å“åº” - ç²’å­å¤§å°éšéŸ³ä¹èŠ‚å¥å˜åŒ–
          if (this.audioLevel > 0) {
            p.currentSize = p.targetSize * (1 + this.audioLevel * 0.5);
          }

          // æ›´æ–°ä½ç½®
          p.x += p.vx;
          p.y += p.vy;

          // è¾¹ç•Œå¼¹æ€§åå¼¹ - ä¸åŒæƒ…ç»ªä¸åŒå¼¹æ€§
          const elasticity = config.bounceElasticity;
          if (p.x < 0) {
            p.x = 0;
            p.vx *= -elasticity;
          }
          if (p.x > this.width) {
            p.x = this.width;
            p.vx *= -elasticity;
          }
          if (p.y < 0) {
            p.y = 0;
            p.vy *= -elasticity;
          }
          if (p.y > this.height) {
            p.y = this.height;
            p.vy *= -elasticity;
          }

          // æ—‹è½¬æ›´æ–°
          p.rotation += p.rotationSpeed;

          // æ¸å…¥æ•ˆæœ
          if (p.currentSize < p.targetSize && this.audioLevel === 0) {
            p.currentSize += 0.5;
          }

          // è®°å½•è½¨è¿¹ - è½¨è¿¹é•¿åº¦éšæƒ…ç»ªå˜åŒ–
          p.trail.push({ x: p.x, y: p.y, alpha: 1.0 });
          if (p.trail.length > p.maxTrailLength) {
            p.trail.shift();
          }

          // è½¨è¿¹æ¸éš
          p.trail.forEach((point, i) => {
            point.alpha = i / p.trail.length;
          });

          // ç²’å­èåˆæ•ˆæœ - è¿‘è·ç¦»ç²’å­ç›¸äº’å¸å¼•
          this.particles.forEach(other => {
            if (other === p) return;
            const dist = Math.hypot(p.x - other.x, p.y - other.y);
            if (dist < 50 && dist > 10) {
              const force = 0.01;
              p.vx += (other.x - p.x) / dist * force;
              p.vy += (other.y - p.y) / dist * force;
            }
          });

          // ç”Ÿå‘½è¡°å‡
          p.life -= p.decay;

          return p.life > 0;
        });

        // ç»´æŒæœ€å°ç²’å­æ•°
        while (this.particles.length < config.particleCount * 0.6) {
          this.particles.push(this.createParticle());
        }
      }

      /**
       * ç»˜åˆ¶ç²’å­
       */
      drawParticles() {
        const ctx = this.ctx;
        const config = this.emotionConfig;

        // åŠ¨æ€èƒŒæ™¯æ¸å˜ - åŸºäºç²’å­å¹³å‡é¢œè‰²
        const avgColor = this.getAverageParticleColor();
        const bgColor = this.interpolateColor('#000000', avgColor, 0.1);
        ctx.fillStyle = this.hexToRgba(bgColor, 0.08);
        ctx.fillRect(0, 0, this.width, this.height);

        // ç»˜åˆ¶æ¯ä¸ªç²’å­
        this.particles.forEach(p => {
          ctx.save();

          // ç»˜åˆ¶è½¨è¿¹ - æ¸éšé€æ˜æ•ˆæœ
          if (p.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(p.trail[0].x, p.trail[0].y);
            for (let i = 1; i < p.trail.length; i++) {
              ctx.lineTo(p.trail[i].x, p.trail[i].y);
            }
            ctx.strokeStyle = p.color;
            ctx.lineWidth = p.size * 0.3;
            ctx.globalAlpha = p.alpha * p.life * 0.4;

            // è½¨è¿¹æ¸å˜
            const gradient = ctx.createLinearGradient(
              p.trail[0].x, p.trail[0].y,
              p.trail[p.trail.length - 1].x, p.trail[p.trail.length - 1].y
            );
            gradient.addColorStop(0, `rgba(0,0,0,0)`);
            gradient.addColorStop(1, p.color);
            ctx.strokeStyle = gradient;

            ctx.stroke();
          }

          // ç»˜åˆ¶ç²’å­
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.globalAlpha = p.alpha * p.life;
          ctx.fillStyle = p.color;

          this.drawShape(ctx, p.shape, p.currentSize);

          ctx.restore();
        });

        // æ›´æ–°å®¹å™¨èƒŒæ™¯è‰²
        this.updateBackgroundColor(avgColor);
      }

      /**
       * ç»˜åˆ¶ä¸åŒå½¢çŠ¶
       */
      drawShape(ctx, shape, size) {
        switch (shape) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'triangle':
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.866, size * 0.5);
            ctx.lineTo(-size * 0.866, size * 0.5);
            ctx.closePath();
            ctx.fill();
            break;

          case 'square':
            ctx.fillRect(-size / 2, -size / 2, size, size);
            break;

          case 'star':
            this.drawStar(ctx, 5, size, size / 2);
            break;

          case 'diamond':
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.7, 0);
            ctx.lineTo(0, size);
            ctx.lineTo(-size * 0.7, 0);
            ctx.closePath();
            ctx.fill();
            break;

          case 'teardrop':
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.bezierCurveTo(size, -size * 0.3, size, size * 0.5, 0, size);
            ctx.bezierCurveTo(-size, size * 0.5, -size, -size * 0.3, 0, -size);
            ctx.fill();
            break;

          case 'oval':
            ctx.beginPath();
            ctx.ellipse(0, 0, size * 0.6, size, 0, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'spike':
            this.drawStar(ctx, 8, size, size * 0.3);
            break;

          default:
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
        }
      }

      /**
       * ç»˜åˆ¶æ˜Ÿå½¢
       */
      drawStar(ctx, points, outerRadius, innerRadius) {
        ctx.beginPath();
        for (let i = 0; i < points * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      /**
       * ç²’å­çˆ†å‘ - ä¸­å¿ƒå¤§çˆ†å‘/è¾¹ç¼˜å°çˆ†å‘
       */
      burstParticles(x, y, isCenter) {
        const count = isCenter ? 20 : 8;
        const speed = isCenter ? 6 : 3;

        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
          const particleSpeed = speed * (0.5 + Math.random());
          const particle = this.createParticle(x, y, {
            size: Math.random() * 15 + 5,
            color: this.emotionConfig.colors[Math.floor(Math.random() * this.emotionConfig.colors.length)]
          });
          particle.vx = Math.cos(angle) * particleSpeed;
          particle.vy = Math.sin(angle) * particleSpeed;
          particle.decay = 0.01;
          this.particles.push(particle);
        }

        // éœ‡åŠ¨åé¦ˆ
        this.vibrate(isCenter ? [50, 30, 50] : 30);
      }

      /**
       * åˆ‡æ¢æƒ…ç»ªæ¨¡å¼
       */
      setEmotion(emotion) {
        if (!EMOTION_CONFIGS[emotion]) return;

        this.currentEmotion = emotion;
        this.emotionConfig = EMOTION_CONFIGS[emotion];

        // æ›´æ–°UI
        document.getElementById('emotionIcon').textContent = this.emotionConfig.icon;
        document.getElementById('emotionName').textContent = this.emotionConfig.name;

        document.querySelectorAll('.emotion-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.emotion === emotion);
        });

        // æ¸…ç©ºç°æœ‰ç²’å­ï¼Œé‡æ–°ç”Ÿæˆ
        this.particles = [];
        this.initParticles();

        // æ¸…ç©ºæ–‡å­—ç²’å­
        this.textParticles = [];
        this.textLayer.innerHTML = '';

        this.showToast(`åˆ‡æ¢åˆ°${this.emotionConfig.name}æ¨¡å¼`);
      }

      /**
       * æ ¹æ®æ‹–åŠ¨é€Ÿåº¦è‡ªåŠ¨åˆ‡æ¢æƒ…ç»ª
       */
      autoSwitchEmotionBySpeed() {
        if (this.touchSpeed > 15) {
          if (this.currentEmotion !== 'energetic') {
            this.setEmotion('energetic');
          }
        } else if (this.touchSpeed > 8) {
          if (this.currentEmotion !== 'angry') {
            this.setEmotion('angry');
          }
        } else if (this.touchSpeed < 2) {
          if (this.currentEmotion !== 'calm') {
            this.setEmotion('calm');
          }
        }
      }

      // ========== æ–‡å­—ç²’å­ç³»ç»Ÿ ==========
      spawnTextParticles() {
        setInterval(() => {
          if (this.textParticles.length < 8 && !this.isPaused) {
            const texts = TEXT_SOURCES[this.currentEmotion] || TEXT_SOURCES.happy;
            const text = texts[Math.floor(Math.random() * texts.length)];
            const color = this.emotionConfig.colors[
              Math.floor(Math.random() * this.emotionConfig.colors.length)
            ];

            const textParticle = {
              id: this.textParticleId++,
              text: text,
              x: Math.random() * (this.width - 100) + 50,
              y: Math.random() * (this.height - 100) + 50,
              vx: (Math.random() - 0.5) * this.emotionConfig.speedMultiplier,
              vy: (Math.random() - 0.5) * this.emotionConfig.speedMultiplier,
              color: color,
              size: (Math.random() * 20 + 14) * this.globalSizeMultiplier,
              opacity: 0,
              targetOpacity: Math.random() * 0.6 + 0.4,
            };

            this.textParticles.push(textParticle);
            this.createTextElement(textParticle);
          }
        }, 3000);
      }

      createTextElement(particle) {
        const el = document.createElement('div');
        el.className = 'text-particle';
        el.id = `text-${particle.id}`;
        el.textContent = particle.text;
        el.style.color = particle.color;
        el.style.fontSize = `${particle.size}px`;
        this.textLayer.appendChild(el);
      }

      updateTextParticles() {
        this.textParticles = this.textParticles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;

          // è¾¹ç•Œæ£€æµ‹
          if (p.x < 0 || p.x > this.width) p.vx *= -1;
          if (p.y < 0 || p.y > this.height) p.vy *= -1;

          // æ¸å…¥æ•ˆæœ
          if (p.opacity < p.targetOpacity) {
            p.opacity = Math.min(p.opacity + 0.02, p.targetOpacity);
          }

          // æ›´æ–°DOM
          const el = document.getElementById(`text-${p.id}`);
          if (el) {
            el.style.left = `${p.x}px`;
            el.style.top = `${p.y}px`;
            el.style.opacity = p.opacity;
          }

          return true;
        });
      }

      // ========== åŠ¨ç”»å¾ªç¯ ==========
      startAnimation() {
        const animate = () => {
          if (!this.isPaused) {
            this.updateParticles();
            this.drawParticles();
            this.updateTextParticles();
            this.updateAudioLevel();
            this.drawAudioVisualizer();
          }
          this.animationId = requestAnimationFrame(animate);
        };
        animate();
      }

      // ========== éŸ³é¢‘ç³»ç»Ÿ ==========
      setupAudio() {
        if (this.audio) return;

        this.audio = new Audio();
        this.audio.loop = true;
        this.audio.volume = 0.3;
        this.audio.crossOrigin = 'anonymous';

        // ç¯å¢ƒéŸ³ä¹èµ„æºï¼ˆå…è´¹ç‰ˆæƒï¼‰
        const audioSources = {
          happy: 'https://cdn.pixabay.com/download/audio/2022/05/27/audio_1808fbf07a.mp3',
          sad: 'https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3',
          angry: 'https://cdn.pixabay.com/download/audio/2022/01/18/audio_d0a13f69d2.mp3',
          calm: 'https://cdn.pixabay.com/download/audio/2021/08/04/audio_12b0c7443c.mp3',
          energetic: 'https://cdn.pixabay.com/download/audio/2022/03/15/audio_ba8704089c.mp3'
        };

        this.audio.src = audioSources[this.currentEmotion] || audioSources.happy;

        // è®¾ç½®éŸ³é¢‘åˆ†æå™¨
        this.setupAudioAnalyser();

        this.audio.addEventListener('ended', () => {
          if (this.isPlayingMusic) {
            this.audio.currentTime = 0;
            this.audio.play();
          }
        });
      }

      setupAudioAnalyser() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 256;
          this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

          // è¿æ¥éŸ³é¢‘æº
          const source = this.audioContext.createMediaElementSource(this.audio);
          source.connect(this.analyser);
          this.analyser.connect(this.audioContext.destination);
        }
      }

      setupAudioVisualizer() {
        // åˆå§‹åŒ–å¯è§†åŒ–ç”»å¸ƒ
        this.visualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.visualizerCtx.fillRect(0, 0, this.width, 100);
      }

      updateAudioLevel() {
        if (this.analyser && this.isPlayingMusic) {
          this.analyser.getByteFrequencyData(this.dataArray);
          const average = this.dataArray.reduce((a, b) => a + b, 0) / this.dataArray.length;
          this.audioLevel = average / 255; // å½’ä¸€åŒ–åˆ° 0-1
        } else {
          this.audioLevel = 0;
        }
      }

      drawAudioVisualizer() {
        if (!this.analyser || !this.isPlayingMusic) return;

        const ctx = this.visualizerCtx;
        const width = this.width;
        const height = 100;
        const bufferLength = this.analyser.frequencyBinCount;
        const barWidth = (width / bufferLength) * 2.5;
        let x = 0;

        ctx.clearRect(0, 0, width, height);

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = (this.dataArray[i] / 255) * height;

          // ä½¿ç”¨æƒ…ç»ªé…è‰²
          const colorIndex = Math.floor((i / bufferLength) * this.emotionConfig.colors.length);
          ctx.fillStyle = this.emotionConfig.colors[colorIndex] || '#fff';

          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }

      toggleMusic() {
        if (!this.audio) {
          this.setupAudio();
        }

        if (this.isPlayingMusic) {
          this.audio.pause();
          this.isPlayingMusic = false;
          document.getElementById('btnMusic').textContent = 'ğŸµ';
        } else {
          // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆæµè§ˆå™¨å¯èƒ½è‡ªåŠ¨æš‚åœï¼‰
          if (this.audioContext && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
          }

          this.audio.play().then(() => {
            this.isPlayingMusic = true;
            document.getElementById('btnMusic').textContent = 'â¸';
          }).catch(err => {
            console.log('éŸ³é¢‘æ’­æ”¾éœ€è¦ç”¨æˆ·äº¤äº’:', err);
          });
        }

        this.vibrate(30);
      }

      // ========== äº‹ä»¶ç»‘å®š ==========
      bindEvents() {
        const canvas = this.canvas;

        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', () => this.onTouchEnd());

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        canvas.addEventListener('mouseup', () => this.onMouseEnd());
        canvas.addEventListener('wheel', (e) => this.onWheel(e));

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => this.onKeyDown(e));

        // æ§åˆ¶æŒ‰é’®
        document.getElementById('btnMusic').addEventListener('click', () => this.toggleMusic());
        document.getElementById('btnSave').addEventListener('click', () => this.saveImage());
        document.getElementById('btnReset').addEventListener('click', () => this.resetCanvas());
        document.getElementById('btnPause').addEventListener('click', () => this.togglePause());

        // é˜²æ­¢å³é”®èœå•
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      }

      bindEmotionButtons() {
        document.querySelectorAll('.emotion-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            this.setEmotion(btn.dataset.emotion);
            this.vibrate(30);
          });
        });
      }

      getEventPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      // è§¦æ‘¸äº‹ä»¶
      onTouchStart(e) {
        e.preventDefault();

        // åŒæŒ‡ç¼©æ”¾
        if (e.touches.length === 2) {
          this.isPinching = true;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          this.pinchStartDistance = Math.hypot(dx, dy);
          this.pinchStartSize = this.globalSizeMultiplier;
          return;
        }

        const pos = this.getEventPos(e);
        this.lastTouchPos = pos;
        this.touchStartTime = Date.now();
        this.lastTouchTime = Date.now();

        // åˆ¤æ–­æ˜¯å¦ä¸­å¿ƒç‚¹å‡»
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const distToCenter = Math.hypot(pos.x - centerX, pos.y - centerY);
        const isCenter = distToCenter < Math.min(this.width, this.height) * 0.2;

        this.burstParticles(pos.x, pos.y, isCenter);

        // é•¿æŒ‰æ£€æµ‹
        this.longPressTimer = setTimeout(() => {
          this.saveImage();
        }, 800);
      }

      onTouchMove(e) {
        e.preventDefault();

        // åŒæŒ‡ç¼©æ”¾
        if (e.touches.length === 2 && this.isPinching) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const currentDistance = Math.hypot(dx, dy);
          const scale = currentDistance / this.pinchStartDistance;
          this.globalSizeMultiplier = Math.max(0.3, Math.min(3.0, this.pinchStartSize * scale));

          // æ›´æ–°ç°æœ‰ç²’å­å¤§å°
          this.particles.forEach(p => {
            p.targetSize = p.size * this.globalSizeMultiplier;
          });

          return;
        }

        const pos = this.getEventPos(e);
        const currentTime = Date.now();
        const dt = currentTime - this.lastTouchTime;
        const dist = Math.hypot(pos.x - this.lastTouchPos.x, pos.y - this.lastTouchPos.y);

        // è®¡ç®—æ‹–åŠ¨é€Ÿåº¦
        this.touchSpeed = dt > 0 ? dist / dt * 1000 : 0;
        this.lastTouchTime = currentTime;

        // æ ¹æ®é€Ÿåº¦è‡ªåŠ¨åˆ‡æ¢æƒ…ç»ª
        this.autoSwitchEmotionBySpeed();

        const dx = pos.x - this.lastTouchPos.x;
        const dy = pos.y - this.lastTouchPos.y;

        // å½±å“é™„è¿‘ç²’å­
        this.particles.forEach(p => {
          const distance = Math.hypot(p.x - pos.x, p.y - pos.y);
          if (distance < 150) {
            p.vx += dx * 0.02;
            p.vy += dy * 0.02;
          }
        });

        this.lastTouchPos = pos;
      }

      onTouchEnd() {
        if (this.isPinching) {
          this.isPinching = false;
        }

        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }

        // é‡ç½®é€Ÿåº¦
        setTimeout(() => {
          this.touchSpeed = 0;
        }, 500);
      }

      // é¼ æ ‡äº‹ä»¶
      onMouseDown(e) {
        const pos = { x: e.clientX, y: e.clientY };
        this.lastTouchPos = pos;
        this.touchStartTime = Date.now();

        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const distToCenter = Math.hypot(pos.x - centerX, pos.y - centerY);
        const isCenter = distToCenter < Math.min(this.width, this.height) * 0.2;

        this.burstParticles(pos.x, pos.y, isCenter);
      }

      onMouseMove(e) {
        if (e.buttons === 1) {
          const pos = { x: e.clientX, y: e.clientY };
          const dx = pos.x - this.lastTouchPos.x;
          const dy = pos.y - this.lastTouchPos.y;

          this.particles.forEach(p => {
            const dist = Math.hypot(p.x - pos.x, p.y - pos.y);
            if (dist < 150) {
              p.vx += dx * 0.02;
              p.vy += dy * 0.02;
            }
          });

          this.lastTouchPos = pos;
        }
      }

      onMouseEnd() {}

      onWheel(e) {
        e.preventDefault();
        // é¼ æ ‡æ»šè½®ç¼©æ”¾
        const delta = e.deltaY > 0 ? 0.95 : 1.05;
        this.globalSizeMultiplier = Math.max(0.3, Math.min(3.0, this.globalSizeMultiplier * delta));

        // æ›´æ–°ç°æœ‰ç²’å­
        this.particles.forEach(p => {
          p.targetSize = p.size * this.globalSizeMultiplier;
        });
      }

      // é”®ç›˜å¿«æ·é”®
      onKeyDown(e) {
        const key = e.key.toLowerCase();

        switch (key) {
          case '1': this.setEmotion('happy'); break;
          case '2': this.setEmotion('sad'); break;
          case '3': this.setEmotion('angry'); break;
          case '4': this.setEmotion('calm'); break;
          case '5': this.setEmotion('energetic'); break;
          case 'm': this.toggleMusic(); break;
          case 's': this.saveImage(); break;
          case 'r': this.resetCanvas(); break;
          case ' ': this.togglePause(); e.preventDefault(); break;
        }
      }

      // ========== åŠŸèƒ½æ–¹æ³• ==========
      saveImage() {
        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }

        this.vibrate([50, 50, 50]);

        // åˆ›å»ºé«˜åˆ†è¾¨ç‡ç”»å¸ƒ
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = this.width * 2;
        exportCanvas.height = this.height * 2;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.scale(2, 2);

        // ç»˜åˆ¶èƒŒæ™¯
        exportCtx.fillStyle = '#000';
        exportCtx.fillRect(0, 0, this.width, this.height);

        // ç»˜åˆ¶ç²’å­
        exportCtx.drawImage(this.canvas, 0, 0);

        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const link = document.createElement('a');
        link.download = `æƒ…ç»ªæ˜Ÿäº‘_${this.currentEmotion}_${Date.now()}.png`;
        link.href = exportCanvas.toDataURL('image/png');
        link.click();

        this.showToast('å›¾ç‰‡å·²ä¿å­˜');
      }

      resetCanvas() {
        this.vibrate([30, 30]);

        // æ¸…é™¤ç²’å­
        this.particles = [];
        this.textParticles = [];
        this.textLayer.innerHTML = '';

        // éšæœºåˆ‡æ¢æƒ…ç»ª
        const emotions = Object.keys(EMOTION_CONFIGS);
        const randomEmotion = emotions[Math.floor(Math.random() * emotions.length)];
        this.setEmotion(randomEmotion);

        // æ¸…ç©ºç”»å¸ƒ
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.showToast('ç”»å¸ƒå·²é‡ç½®');
      }

      togglePause() {
        this.isPaused = !this.isPaused;
        document.getElementById('btnPause').textContent = this.isPaused ? 'â–¶ï¸' : 'â¸ï¸';
        this.showToast(this.isPaused ? 'å·²æš‚åœ' : 'ç»§ç»­æ’­æ”¾');
        this.vibrate(30);
      }

      vibrate(pattern) {
        if (navigator.vibrate) {
          navigator.vibrate(pattern);
        }
      }

      showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.remove('show');
        void toast.offsetWidth; // è§¦å‘é‡æ’
        toast.classList.add('show');
      }

      // ========== è¾…åŠ©æ–¹æ³• ==========
      getAverageParticleColor() {
        if (this.particles.length === 0) return '#000000';

        let r = 0, g = 0, b = 0;
        let count = 0;

        this.particles.forEach(p => {
          const rgb = this.hexToRgb(p.color);
          if (rgb) {
            r += rgb.r;
            g += rgb.g;
            b += rgb.b;
            count++;
          }
        });

        if (count === 0) return '#000000';

        r = Math.round(r / count);
        g = Math.round(g / count);
        b = Math.round(b / count);

        return this.rgbToHex(r, g, b);
      }

      updateBackgroundColor(color) {
        const rgba = this.hexToRgba(color, 0.1);
        this.container.style.background = rgba;
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
          const hex = x.toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        }).join('');
      }

      hexToRgba(hex, alpha) {
        const rgb = this.hexToRgb(hex);
        return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})` : `rgba(0, 0, 0, ${alpha})`;
      }

      interpolateColor(color1, color2, factor) {
        const rgb1 = this.hexToRgb(color1);
        const rgb2 = this.hexToRgb(color2);

        if (!rgb1 || !rgb2) return color1;

        const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
        const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
        const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);

        return this.rgbToHex(r, g, b);
      }

      // ========== æ‰©å±•æ¥å£ ==========
      /**
       * å¯¼å‡ºGIFåŠ¨ç”»ï¼ˆéœ€è¦gif.jsåº“ï¼‰
       * æ‰©å±•ç‚¹ï¼šå¯é›†æˆç¬¬ä¸‰æ–¹åº“å®ç°
       */
      async exportGIF() {
        // TODO: é›†æˆgif.jsæˆ–gifshotåº“
        this.showToast('GIFå¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...');
        console.log('[æ‰©å±•] GIFå¯¼å‡ºæ¥å£å·²é¢„ç•™');
      }

      /**
       * è¯­éŸ³æ§åˆ¶æƒ…ç»ªåˆ‡æ¢
       * æ‰©å±•ç‚¹ï¼šå¯é›†æˆWeb Speech API
       */
      async voiceControl() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          this.showToast('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
          return;
        }

        // TODO: å®ç°è¯­éŸ³è¯†åˆ«é€»è¾‘
        this.showToast('è¯­éŸ³æ§åˆ¶åŠŸèƒ½å¼€å‘ä¸­...');
        console.log('[æ‰©å±•] è¯­éŸ³äº¤äº’æ¥å£å·²é¢„ç•™');
      }

      /**
       * è‡ªå®šä¹‰æƒ…ç»ªé…ç½®
       * æ‰©å±•ç‚¹ï¼šå…è®¸ç”¨æˆ·è‡ªå®šä¹‰æƒ…ç»ªæ¨¡å¼
       */
      customEmotion(config) {
        // TODO: å®ç°è‡ªå®šä¹‰æƒ…ç»ªé€»è¾‘
        console.log('[æ‰©å±•] è‡ªå®šä¹‰æƒ…ç»ªæ¥å£å·²é¢„ç•™', config);
      }
    }

    // ========== å¯åŠ¨åº”ç”¨ ==========
    window.addEventListener('DOMContentLoaded', () => {
      const app = new EmotionNebula();

      // æš´éœ²åˆ°å…¨å±€ä»¥ä¾¿æ‰©å±•è°ƒç”¨
      window.EmotionNebulaApp = app;

      console.log('%cæƒ…ç»ªæ˜Ÿäº‘ Pro', 'color: #4ECDC4; font-size: 24px; font-weight: bold;');
      console.log('%cç²’å­ç³»ç»Ÿå·²å¯åŠ¨ | å¿«æ·é”®: 1-5 æƒ…ç»ª | M éŸ³ä¹ | S ä¿å­˜ | R é‡ç½® | Space æš‚åœ',
                  'color: #888; font-size: 12px;');
    });
  </script>
</body>
</html>
