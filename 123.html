<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­åœ£è¯æ ‘ - æ‰‹åŠ¿äº’åŠ¨</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: sans-serif; }

        #ui {
            position: absolute;
            top: 20px; left: 0; width: 100%;
            text-align: center;
            pointer-events: none;
            color: #fff;
            text-shadow: 0 0 10px #ff0055;
            z-index: 10;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; font-size: 2rem; }
        p { font-size: 0.9rem; opacity: 0.8; margin-top: 5px; }

        #cam-preview {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.3);
            transform: scaleX(-1);
            opacity: 0.8;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: gold;
            font-size: 1.2rem;
            transition: opacity 0.5s;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>MERRY CHRISTMAS</h1>
        <p>âœŠ æ¡æ‹³ï¼šå‡èšæˆæ ‘ | ğŸ– å¼ æ‰‹ï¼šç‚¸è£‚æ•£å¼€</p>
    </div>

    <div id="loading">æ­£åœ¨è£…é…é­”æ³•ç²’å­...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    <video id="input-video" style="display:none"></video>
    <canvas id="cam-preview"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // 1. åœºæ™¯é…ç½®
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // ==========================================
        // 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ (æ ¸å¿ƒç®—æ³•)
        // ==========================================
        const particleCount = 25000;
        const geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(particleCount * 3); // å½“å‰ä½ç½®
        const targets = new Float32Array(particleCount * 3);   // æ ‘å½¢æ€çš„ç›®æ ‡ä½ç½®
        const colors = new Float32Array(particleCount * 3);    // é¢œè‰²
        const sizes = new Float32Array(particleCount);         // å¤§å°å·®å¼‚
        const velocities = new Float32Array(particleCount * 3); // çˆ†ç‚¸æ—¶çš„é€Ÿåº¦

        const colorGreen = new THREE.Color(0x2f5a2f); // æ ‘å¶ç»¿
        const colorBright = new THREE.Color(0x4caf50); // äº®ç»¿
        const colorGold = new THREE.Color(0xffd700);   // é‡‘è‰²è£…é¥°
        const colorRed = new THREE.Color(0xff0055);    // çº¢è‰²è£…é¥°
        const colorBlue = new THREE.Color(0x00ffff);   // è“è‰²è£…é¥°

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            // --- A. ç”Ÿæˆåœ£è¯æ ‘å½¢æ€ (èºæ—‹åœ†é”¥) ---
            // y: é«˜åº¦ï¼Œä» -15 åˆ° 15
            const y = (Math.random() * 30) - 15;
            // normalizedY: 0 (åº•éƒ¨) åˆ° 1 (é¡¶éƒ¨)
            const ny = (y + 15) / 30;

            // åŠå¾„éšç€é«˜åº¦å¢åŠ è€Œå‡å° (åœ†é”¥)ï¼Œä½†ä¹ŸåŠ ä¸€ç‚¹éšæœºå™ªç‚¹è®©æ ‘æ˜¾å¾—è“¬æ¾
            const radiusBase = (1 - ny) * 12;
            const radius = radiusBase + (Math.random() - 0.5) * 2;

            // èºæ—‹è§’åº¦
            const angle = y * 5 + Math.random() * Math.PI * 2;

            // è®¡ç®—ç›®æ ‡åæ ‡
            const tx = Math.cos(angle) * radius;
            const ty = y;
            const tz = Math.sin(angle) * radius;

            targets[i3] = tx;
            targets[i3+1] = ty;
            targets[i3+2] = tz;

            // --- B. åˆå§‹åŒ–ä½ç½® (éšæœºæ•£è½åœ¨å®‡å®™ä¸­) ---
            positions[i3] = (Math.random() - 0.5) * 100;
            positions[i3+1] = (Math.random() - 0.5) * 100;
            positions[i3+2] = (Math.random() - 0.5) * 100;

            // --- C. åˆå§‹åŒ–çˆ†ç‚¸é€Ÿåº¦å‘é‡ (å‘å¤–) ---
            velocities[i3] = (Math.random() - 0.5) * 0.5;
            velocities[i3+1] = (Math.random() - 0.5) * 0.5;
            velocities[i3+2] = (Math.random() - 0.5) * 0.5;

            // --- D. é¢œè‰²åˆ†é…é€»è¾‘ ---
            let c = new THREE.Color();
            let size = 0.2;

            if (ny > 0.98) {
                // æ ‘é¡¶ï¼šæ˜Ÿæ˜Ÿ (é‡‘è‰²ï¼Œå¤§)
                c.copy(colorGold);
                size = 1.0;
            } else if (Math.random() > 0.9) {
                // è£…é¥°çƒ (çº¢/é‡‘/è“)
                const rand = Math.random();
                if(rand < 0.33) c.copy(colorRed);
                else if(rand < 0.66) c.copy(colorGold);
                else c.copy(colorBlue);
                size = 0.6; // è£…é¥°çƒç¨å¾®å¤§ä¸€ç‚¹
            } else {
                // æ ‘å¶ (æ·±ç»¿/æµ…ç»¿æ··åˆ)
                c.copy(Math.random() > 0.5 ? colorGreen : colorBright);
                // æ ‘å¶ç¨å¾®éšæœºä¸€ç‚¹äº®åº¦
                c.multiplyScalar(0.8 + Math.random() * 0.4);
            }

            colors[i3] = c.r;
            colors[i3+1] = c.g;
            colors[i3+2] = c.b;
            sizes[i] = size;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // ç®€å•çš„åœ†å½¢çº¹ç†
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // è‡ªå®šä¹‰ç€è‰²å™¨æè´¨ (ä¸ºäº†æ›´å¥½çš„æ§åˆ¶ç²’å­å¤§å°å’Œé¢œè‰²)
        // è¿™é‡Œä½¿ç”¨æ ‡å‡† PointsMaterial ä»¥ç®€åŒ–å…¼å®¹æ€§ï¼Œé…åˆ vertexColors
        const material = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            map: getTexture(),
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.9
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- æ·»åŠ åœ°æ¿å…‰æ™• (è®©åœºæ™¯ä¸é‚£ä¹ˆç©º) ---
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x001100, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -18;
        scene.add(ground);

        // ==========================================
        // 3. æ‰‹åŠ¿ä¸ç‰©ç†é€»è¾‘
        // ==========================================
        const state = {
            openness: 0, // 0 = æ¡æ‹³ (Tree), 1 = å¼ æ‰‹ (Scatter)
            smoothedOpenness: 0 // å¹³æ»‘å€¼
        };

        const previewCanvas = document.getElementById('cam-preview');
        const ctx = previewCanvas.getContext('2d');
        previewCanvas.width = 160; previewCanvas.height = 120;

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            ctx.clearRect(0, 0, 160, 120);
            ctx.drawImage(results.image, 0, 0, 160, 120);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // è®¡ç®—æŒ‡å°–åˆ°æŒå¿ƒçš„å¹³å‡è·ç¦»æ¥åˆ¤æ–­å¼ å¼€ç¨‹åº¦
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20];
                let avgDist = 0;

                tips.forEach(idx => {
                    const d = Math.sqrt(
                        Math.pow(landmarks[idx].x - wrist.x, 2) +
                        Math.pow(landmarks[idx].y - wrist.y, 2)
                    );
                    avgDist += d;
                });
                avgDist /= 5;

                // ç®€å•çš„æ˜ å°„ï¼š0.2ä»¥ä¸‹è®¤ä¸ºæ˜¯æ‹³å¤´ï¼Œ0.4ä»¥ä¸Šè®¤ä¸ºæ˜¯å¼ å¼€
                // ç»“æœæ˜ å°„åˆ° 0 ~ 1
                state.openness = Math.min(1, Math.max(0, (avgDist - 0.15) / 0.25));

                // è§†è§‰åé¦ˆï¼šç”»éª¨æ¶
                ctx.strokeStyle = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(wrist.x*160, wrist.y*120);
                ctx.lineTo(landmarks[9].x*160, landmarks[9].y*120);
                ctx.stroke();

            } else {
                // æ²¡æ‰‹çš„æ—¶å€™ï¼Œé»˜è®¤å˜å›æ ‘
                state.openness = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(document.getElementById('input-video'), {
            onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
            width: 320, height: 240
        });
        cameraUtils.start();

        // ==========================================
        // 4. åŠ¨ç”»å¾ªç¯
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            controls.update();

            // å¹³æ»‘æ‰‹åŠ¿å€¼
            state.smoothedOpenness += (state.openness - state.smoothedOpenness) * 0.1;

            const posArr = geometry.attributes.position.array;
            const sizeArr = geometry.attributes.size.array; // ç”¨æ¥åšé—ªçƒæ•ˆæœ

            // æ ¸å¿ƒç‰©ç†é€»è¾‘
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;

                // ç›®æ ‡ä½ç½® (æ ‘)
                const tx = targets[idx];
                const ty = targets[idx+1];
                const tz = targets[idx+2];

                // å½“å‰ä½ç½®
                let px = posArr[idx];
                let py = posArr[idx+1];
                let pz = posArr[idx+2];

                // --- é—ªçƒæ•ˆæœ (Twinkle) ---
                // åªæœ‰åœ¨å˜æˆæ ‘çš„æ—¶å€™æ‰é—ªçƒ
                if (state.smoothedOpenness < 0.5) {
                     const blink = Math.sin(time * 3 + i) * 0.5 + 0.5;
                     // åŠ¨æ€ä¿®æ”¹ size å±æ€§éœ€è¦ Shader æ”¯æŒï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡å¾®è°ƒä½ç½®äº§ç”Ÿéœ‡åŠ¨æ„Ÿï¼Œæˆ–è€…è¿™é‡Œç®€åŒ–ä¸åš
                     // ç®€å•é¢œè‰²äº®åº¦éœ‡åŠ¨ï¼ˆç•¥è¿‡ï¼Œä¸ºäº†æ€§èƒ½ï¼‰
                }

                // --- ç‰©ç†åŠ›åœº ---

                if (state.smoothedOpenness > 0.5) {
                    // A. æ•£å¼€æ¨¡å¼ (Explode/Scatter)
                    // ç²’å­åŠ ä¸Šéšæœºé€Ÿåº¦å‘å¤–é£
                    // æ ¹æ® Openness å¼ºåº¦å†³å®šé£æ•£ç¨‹åº¦

                    const noiseX = Math.sin(time * 2 + i) * 0.1;
                    const noiseY = Math.cos(time * 3 + i) * 0.1;

                    // å¾€å¤–æ¨çš„åŠ›
                    px += (velocities[idx] + noiseX) * state.smoothedOpenness * 0.5;
                    py += (velocities[idx+1] + noiseY) * state.smoothedOpenness * 0.5;
                    pz += (velocities[idx+2] + noiseX) * state.smoothedOpenness * 0.5;

                    // ç¨å¾®æ—‹è½¬æ•´ä¸ªäº‘å›¢
                    const rotSpeed = 0.001;
                    const cos = Math.cos(rotSpeed);
                    const sin = Math.sin(rotSpeed);
                    const nx = px * cos - pz * sin;
                    const nz = px * sin + pz * cos;
                    px = nx; pz = nz;

                } else {
                    // B. èšåˆæ¨¡å¼ (Tree)
                    // å¼ºåŠ› Lerp å›å½’åˆ° targets ä½ç½®
                    const speed = 0.08; // å›å½’é€Ÿåº¦
                    px += (tx - px) * speed;
                    py += (ty - py) * speed;
                    pz += (tz - pz) * speed;
                }

                posArr[idx] = px;
                posArr[idx+1] = py;
                posArr[idx+2] = pz;
            }

            geometry.attributes.position.needsUpdate = true;

            // æ‘„åƒæœºç¨å¾®åŠ¨ä¸€åŠ¨ï¼Œå¢åŠ æ²‰æµ¸æ„Ÿ
            // camera.position.y += Math.sin(time) * 0.02;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>